#include "World.h"
#include "Ray.h"

/* ------------------------------------------------------------------------------------------------ */
/* -------------------------------------- World Constructor --------------------------------------- */
/* ------------------------------------------------------------------------------------------------ */
World::World(shared_ptr<Hittables> object)
{
	AddObject(object);
}

World::~World()
{
	/* - Clears World - */
	m_SceneGeometry.clear(); 
}
/* ------------------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------------------ */


/* ------------------------------------------------------------------------------------------------ */
/* ------------------------------------ Add Objects To World -------------------------------------- */
/* ------------------------------------------------------------------------------------------------ */
int World::AddObject(shared_ptr<Hittables> object)
{
	m_SceneGeometry.push_back(object);
	return m_SceneGeometry.size() - 1;
}

int World::AddMaterial(shared_ptr<Material> mat)
{
	m_ObjectMaterials.push_back(mat);
	return m_ObjectMaterials.size() - 1;
}
/* ------------------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------------------ */


/* ------------------------------------------------------------------------------------------------ */
/* ------------------------------------ Check If World Is Hit ------------------------------------- */
/* ------------------------------------------------------------------------------------------------ */
bool World::hit(const Ray& ray, float t_min, float t_max, RayPayload& rec) const
{
	RayPayload temp_rec;
	bool hit_anything = false;
	auto closest_so_far = t_max;
	int objectIndex = 0;

	for (const auto& object : m_SceneGeometry)
	{
		if (object->hit(ray, t_min, closest_so_far, temp_rec))
		{
			hit_anything = true;
			closest_so_far = temp_rec.closestT;
			rec = temp_rec;
			rec.objIdx = objectIndex;
		}
		objectIndex++;
	}

	return hit_anything;
}
/* ------------------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------------------ */


/* ------------------------------------------------------------------------------------------------ */
/* ---------------------------------- Calculate Object Hit Values --------------------------------- */
/* ------------------------------------------------------------------------------------------------ */
void World::ClosestHitShader(const Ray& ray, RayPayload& rec) const
{
	m_SceneGeometry[rec.objIdx]->ClosestHitShader(ray, rec);
	
}
/* ------------------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------------------ */
